/*	time-series-graph 0.5.0 by Zachary Forest Johnson	hosted at code.google.com/p/time-series-graph	version posted 2007_10_23 at 10:48 CST	Contact:	indiemaps.com	zach.f.johnson@gmail.com*/package com.indiemaps.charting{	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.events.MouseEvent;	import flash.events.Event;	import flash.geom.Rectangle;	import fl.transitions.*;	import fl.transitions.easing.*;	import flash.utils.setInterval;	import flash.utils.clearInterval;	import flash.text.TextField;	import flash.text.TextFieldAutoSize;	public class TimeSeriesGraph extends MovieClip {		var secondGraph = false;		var mainHeight;		var smallHeight;		var mainWidth;		var smallWidth;		var secondGraphHeight;		var totalWidth;		var totalHeight;		var totalGraphHeight;		var graphHolder:Sprite = new Sprite();		var mainGraph:Sprite = new Sprite();		var smallGraph:Sprite = new Sprite();		var blueGraph:Sprite = new Sprite();		var largeMask:Sprite = new Sprite();		var background:Sprite = new Sprite();		var dot:Sprite = new Sprite();		var bar:Sprite = new Sprite();		var grid:Sprite = new Sprite();		var barGraph:Sprite = new Sprite();		var handleMask:Sprite = new Sprite();		const magicMultiplier = .0000001;		var sliderLeft;		var sliderRight;		var dateArray:Array;		var valueArray:Array;		var positionArray:Array = new Array();		var realPositionArray:Array = new Array();		var secondDateArray:Array = new Array();		var secondValueArray:Array = new Array();		var secondPositionArray = new Array();		var secondRealPositionArray = new Array();		var controller:MovieClip;		var graphBox:Sprite = new Sprite();		var totalTimeWidth;		var mouseOffTarget;		var buttonInterval;		var hasGraph = false;		var mainLabel = "var1";		var secondLabel = "var2";		var mainPost = "";		var secondPost = "";		var keyArray:Array = new Array();		var leftDate:Date;		var rightDate:Date;		public static  const RANGE_CHANGING:String = "rangeChanging";		public static  const RANGE_CHANGED:String = "rangeChanged";		public function TimeSeriesGraph(controller:MovieClip) {			//set up a controller to allow this class to reach the main root/stage level (may not need this)			this.controller = controller;			//add the border at level one (which is below the handles but above the wholeSlider			this.addChildAt(graphBox, 1);			this.noData();		}		//this function is called immediately (by default) and is also a public method for if the user wishes to have the timeseries		//graph on the stage, but does not wish to pass it any data (yet) 		public function noData() {			this.hasGraph = false;			//remove all the event listeners			this.wholeSlider.middleSlider.removeEventListener(MouseEvent.MOUSE_DOWN, dragSlider);			this.leftHandle.removeEventListener(MouseEvent.MOUSE_DOWN, dragHandle);			this.rightHandle.removeEventListener(MouseEvent.MOUSE_DOWN, dragHandle);			this.wholeSlider.left.removeEventListener(MouseEvent.MOUSE_DOWN, slide);			this.wholeSlider.right.removeEventListener(MouseEvent.MOUSE_DOWN, slide);			this.background.removeEventListener(MouseEvent.ROLL_OVER, showSpecifics);			this.background.removeEventListener(MouseEvent.ROLL_OUT, showDateRange);			if (this.contains(graphHolder)) {				removeChild(largeMask);				removeChild(handleMask);				removeChild(graphHolder);				removeChild(background);				removeChild(dot);				removeChild(bar);				graphHolder.removeChild(grid);				graphHolder.removeChild(mainGraph);				removeChild(blueGraph);				removeChild(smallGraph);				if (secondGraph) {					graphHolder.removeChild(barGraph);					secondGraph = false;				}			}		}		function moveMiddleSlider() {//the function called on resize which reverses the standard graph position formulae			this.wholeSlider.middleSlider.x = -(this.graphHolder.x / (this.graphHolder.width - 0)) * this.smallWidth + this.wholeSlider.left.width;			trace(this.mainWidth + ", " + this.graphHolder.width);			this.wholeSlider.middleSlider.bg.width = (this.mainWidth / this.graphHolder.width) * this.smallWidth;			if (this.wholeSlider.middleSlider.bg.width > this.smallWidth) {				this.wholeSlider.middleSlider.bg.width = this.smallWidth;				this.wholeSlider.middleSlider.x = this.wholeSlider.left.width;				this.placeHandles();				positionGraph(false);			} else if (this.wholeSlider.middleSlider.x > ((this.smallWidth + this.wholeSlider.left.width)-this.wholeSlider.middleSlider.bg.width)) {				this.wholeSlider.middleSlider.x = ((this.smallWidth + this.wholeSlider.left.width)-this.wholeSlider.middleSlider.bg.width);				this.placeHandles();				positionGraph(false);			} else {				this.placeHandles();			}		}		//this should be called the first time the user wants to pass arrays to the class (using the public methods)		//it should also be used IF the user has already called the public method noData()		function firstGraphing() {			this.hasGraph = true;			//some event listeners			this.wholeSlider.middleSlider.addEventListener(MouseEvent.MOUSE_DOWN, dragSlider);			this.leftHandle.addEventListener(MouseEvent.MOUSE_DOWN, dragHandle);			this.rightHandle.addEventListener(MouseEvent.MOUSE_DOWN, dragHandle);			this.wholeSlider.left.addEventListener(MouseEvent.MOUSE_DOWN, slide);			this.wholeSlider.right.addEventListener(MouseEvent.MOUSE_DOWN, slide);			//set up the event listener for when the user rolls over the graph -- calls showSpecifics()			this.background.addEventListener(MouseEvent.ROLL_OVER, showSpecifics);			this.background.addEventListener(MouseEvent.ROLL_OUT, showDateRange);			//and draw the dot sprite which will be attached to the graph on mouseover			dot.graphics.clear();			dot.graphics.beginFill(0x0066cc);			dot.graphics.drawCircle(0,0,3);			dot.mouseEnabled = false;			bar.graphics.clear();			bar.graphics.beginFill(0xcc0000);			bar.graphics.drawRect(-2,0,4,-4);			bar.mouseEnabled = false;			//add all the children			addChild(largeMask);			addChild(handleMask);			addChildAt(graphHolder, this.getChildIndex(graphBox));			addChild(background);			addChild(dot);			addChild(bar);			graphHolder.addChild(grid);			graphHolder.addChild(mainGraph);			addChildAt(blueGraph,1);			addChildAt(smallGraph,1);			//start out with the bar and dot invisible			this.dot.visible = false;			this.bar.visible = false;			//draw the masks			largeMask.graphics.clear();			largeMask.graphics.beginFill(0xDDDDDD);			largeMask.graphics.drawRect(0,0,100, 100);			largeMask.y = graphHolder.y;			handleMask.graphics.clear();			handleMask.graphics.beginFill(0xDDDDDD);			handleMask.graphics.drawRect(0,0,this.rightHandle.x-this.leftHandle.x, smallHeight+1);			background.graphics.clear();			background.graphics.beginFill(0xDDDDDD, 0);			background.graphics.drawRect(0,0,100, 100);			background.y = graphHolder.y;		}		public function setGraphSize(w, h) {			this.totalWidth = w;			this.totalHeight = h;			this.mainWidth = w;			if (this.secondGraph) {				this.mainHeight = (4/7) * (h - (this.header.height + this.wholeSlider.height + 20));				this.smallHeight = (1/7) * (h - (this.header.height + this.wholeSlider.height + 20));				this.secondGraphHeight = (1.5/7) * (h - (this.header.height + this.wholeSlider.height + 20));			} else {				this.mainHeight = (5.5/7) * (h - (this.header.height + this.wholeSlider.height + 20));				this.smallHeight = (1/7) * (h - (this.header.height + this.wholeSlider.height + 20));				this.secondGraphHeight = 0;			}			this.totalGraphHeight = mainHeight + secondGraphHeight + 15;// the 15 is for the grid rectangle			this.smallWidth = mainWidth - (this.wholeSlider.left.width * 2);			//set up the header			this.header.bg.width = w;			this.header.x = 0;			this.header.y = 0;			this.header.dateText.autoSize = TextFieldAutoSize.RIGHT;			this.header.dateText.text = "";			this.header.dateText.x = w - 15;			this.graphHolder.y = this.header.y + this.header.height + 5;			//set up the slider positions			this.wholeSlider.left.x = 0;			this.wholeSlider.channel.x = this.wholeSlider.left.width;			this.wholeSlider.channel.width = w - (this.wholeSlider.left.width-1)*2;			this.wholeSlider.right.x = w;			this.wholeSlider.y = h - this.wholeSlider.height;			largeMask.width = mainWidth;			largeMask.height = totalGraphHeight;			background.width = mainWidth;			background.height = totalGraphHeight;			if (this.hasGraph) {				this.smallGraph.y = this.wholeSlider.y - 1;				this.blueGraph.y = smallGraph.y;				handleMask.x = leftHandle.x;				handleMask.y = smallGraph.y - smallHeight;				handleMask.height = smallHeight + 1;				fixRange();				//smallGraph.width = smallWidth;				smallGraph.height = smallHeight;				blueGraph.height = smallHeight;				//blueGraph.width = smallWidth;				mainGraph.height = mainHeight;				this.mainGraph.y = mainHeight;				if (this.secondGraph) {					if (this.barGraph.height > 0) {						this.barGraph.height = 1.0 * secondGraphHeight;						this.barGraph.y = this.totalGraphHeight;					}				}								moveMiddleSlider();				this.drawGrid();								this.showDateRange(null);				dispatchEvent(new Event(TimeSeriesGraph.RANGE_CHANGED));			}			//initially draw the borders of the graph and place the handles			this.placeHandles();			this.drawBorder();		}		function fixRange() {			if (this.secondGraph && this.barGraph.height > 0) {				totalTimeWidth = Math.max(dateArray[dateArray.length-1].valueOf(), secondDateArray[secondDateArray.length-1].valueOf()) - Math.min(dateArray[0].valueOf(), secondDateArray[0].valueOf());				mainGraph.width = ((dateArray[dateArray.length-1].valueOf() - dateArray[0].valueOf()) / totalTimeWidth) * (totalTimeWidth * magicMultiplier);				blueGraph.width = smallGraph.width = ((dateArray[dateArray.length-1].valueOf() - dateArray[0].valueOf()) / totalTimeWidth) * smallWidth;				mainGraph.x = ((dateArray[0].valueOf() - Math.min(dateArray[0].valueOf(), secondDateArray[0].valueOf())) / totalTimeWidth) * (totalTimeWidth * magicMultiplier);				blueGraph.x = smallGraph.x = ((dateArray[0].valueOf() - Math.min(dateArray[0].valueOf(), secondDateArray[0].valueOf())) / totalTimeWidth)*smallWidth + this.wholeSlider.left.width;				barGraph.width = ((secondDateArray[secondDateArray.length-1].valueOf() - secondDateArray[0].valueOf()) / totalTimeWidth) * (totalTimeWidth * magicMultiplier);				barGraph.x = ((secondDateArray[0].valueOf() - Math.min(dateArray[0].valueOf(), secondDateArray[0].valueOf())) / totalTimeWidth) * (totalTimeWidth * magicMultiplier);			} else {				totalTimeWidth = dateArray[dateArray.length-1].valueOf() - dateArray[0].valueOf();				mainGraph.width = ((dateArray[dateArray.length-1].valueOf() - dateArray[0].valueOf()) / totalTimeWidth) * (totalTimeWidth * magicMultiplier);				blueGraph.width = smallGraph.width = ((dateArray[dateArray.length-1].valueOf() - dateArray[0].valueOf()) / totalTimeWidth) * smallWidth;				mainGraph.x = 0;				blueGraph.x = smallGraph.x = ((dateArray[0].valueOf() - dateArray[0].valueOf()) / totalTimeWidth) + this.wholeSlider.left.width;			}		}		function drawGrid() {			grid.graphics.clear();			grid.graphics.lineStyle(1, 0xCCCCCC,1,false,"none");			grid.graphics.beginFill(0xa3dafe, .65);			grid.graphics.drawRect(0,0,graphHolder.width/graphHolder.scaleX, 15 );			/*if (secondGraph) {				grid.graphics.moveTo(0,barGraph.y - mainGraph.y - .5);				grid.graphics.lineTo(graphHolder.width/graphHolder.scaleX, barGraph.y - mainGraph.y - .5);			}*/			grid.y = mainGraph.y;		}		function slide(e:MouseEvent) {			if (e.target == this.wholeSlider.left) {				wholeSlider.middleSlider.x -= 5;				if (wholeSlider.middleSlider.x < this.wholeSlider.left.width) {					wholeSlider.middleSlider.x = this.wholeSlider.left.width;				}			} else if (e.target == this.wholeSlider.right) {				wholeSlider.middleSlider.x += 5;				if (wholeSlider.middleSlider.x > mainWidth-this.wholeSlider.right.width - this.wholeSlider.middleSlider.width) {					wholeSlider.middleSlider.x = mainWidth-this.wholeSlider.right.width - this.wholeSlider.middleSlider.width;				}			}			this.placeHandles();			this.drawBorder();			positionGraph(false);			this.mouseOffTarget = e.target;			this.controller.stage.addEventListener(MouseEvent.MOUSE_UP, handleMouseUp);			buttonInterval = setInterval(sliding, 20);			dispatchEvent(new Event(TimeSeriesGraph.RANGE_CHANGING));		}		function sliding() {			if (this.mouseOffTarget == this.wholeSlider.left) {				wholeSlider.middleSlider.x -= 3;				if (wholeSlider.middleSlider.x < this.wholeSlider.left.width) {					wholeSlider.middleSlider.x = this.wholeSlider.left.width;					clearInterval(buttonInterval);				}			} else if (this.mouseOffTarget == this.wholeSlider.right) {				wholeSlider.middleSlider.x += 3;				if (wholeSlider.middleSlider.x > mainWidth-this.wholeSlider.right.width - this.wholeSlider.middleSlider.width) {					wholeSlider.middleSlider.x = mainWidth-this.wholeSlider.right.width - this.wholeSlider.middleSlider.width;					clearInterval(buttonInterval);				}			}			this.placeHandles();			this.drawBorder();			positionGraph(false);			showDateRange(null);		}		function dragHandle(e:MouseEvent) {			this.mouseOffTarget = e.target;			this.controller.stage.addEventListener(MouseEvent.MOUSE_MOVE, handleDragging);			this.controller.stage.addEventListener(MouseEvent.MOUSE_UP, handleMouseUp);			if (e.target == this.leftHandle) {				this.leftHandle.startDrag(false, new Rectangle(this.wholeSlider.left.width, this.leftHandle.y, (this.rightHandle.x - this.rightHandle.width * .5) - this.wholeSlider.left.width, 0));			} else if (e.target == this.rightHandle) {				this.rightHandle.startDrag(false, new Rectangle(this.leftHandle.x + this.leftHandle.width * .5, this.rightHandle.y, (mainWidth-(this.wholeSlider.left.width * 1))-(this.leftHandle.x + this.leftHandle.width * .5), 0));			}		}		function handleDragging(e:MouseEvent) {			showDateRange(null);			drawBorder();		}		function placeHandles() {			this.leftHandle.x = this.wholeSlider.x + this.wholeSlider.middleSlider.x;			this.rightHandle.x = this.wholeSlider.x + this.wholeSlider.middleSlider.x + this.wholeSlider.middleSlider.width;			this.leftHandle.y = this.rightHandle.y = this.wholeSlider.y - (.5 * (this.wholeSlider.y - (totalGraphHeight + graphHolder.y)));			moveHandleMask();		}		function moveHandleMask() {			if (handleMask.width > 0) {				handleMask.x = leftHandle.x;				handleMask.width = rightHandle.x - leftHandle.x;			}		}		function drawBorder() {			this.graphBox.graphics.clear();			this.graphBox.graphics.lineStyle(1.25, 0x000000);			//move to the upper left			this.graphBox.graphics.moveTo(0,this.graphHolder.y);			this.graphBox.graphics.lineTo(mainWidth, this.graphHolder.y);			this.graphBox.graphics.lineTo(mainWidth, this.graphHolder.y + totalGraphHeight);			this.graphBox.graphics.lineTo(this.rightHandle.x, this.graphHolder.y + totalGraphHeight);			this.graphBox.graphics.lineTo(this.rightHandle.x, this.wholeSlider.y);			this.graphBox.graphics.lineTo(this.wholeSlider.x + this.wholeSlider.middleSlider.x + this.wholeSlider.middleSlider.width, this.wholeSlider.y);			this.graphBox.graphics.lineTo(this.wholeSlider.x + this.wholeSlider.middleSlider.x + this.wholeSlider.middleSlider.width, this.wholeSlider.y + this.wholeSlider.height);			this.graphBox.graphics.lineTo(this.wholeSlider.x + this.wholeSlider.middleSlider.x, this.wholeSlider.y + this.wholeSlider.height);			this.graphBox.graphics.lineTo(this.wholeSlider.x + this.wholeSlider.middleSlider.x, this.wholeSlider.y);			this.graphBox.graphics.lineTo(this.leftHandle.x, this.wholeSlider.y);			this.graphBox.graphics.lineTo(this.leftHandle.x, this.graphHolder.y + totalGraphHeight);			this.graphBox.graphics.lineTo(0, this.graphHolder.y + totalGraphHeight);			this.graphBox.graphics.lineTo(0,this.graphHolder.y);		}		function dragSlider(e:MouseEvent) {			this.controller.stage.addEventListener(MouseEvent.MOUSE_MOVE, sliderDragging);			this.controller.stage.addEventListener(MouseEvent.MOUSE_UP, handleMouseUp);			this.mouseOffTarget = this.wholeSlider.middleSlider;			dispatchEvent(new Event(TimeSeriesGraph.RANGE_CHANGING));			this.wholeSlider.middleSlider.startDrag(false, new Rectangle(this.wholeSlider.left.width, 0, mainWidth-(this.wholeSlider.left.width * 2)-this.wholeSlider.middleSlider.width, 0));		}		function sliderDragging(e:MouseEvent) {			positionGraph(false);			this.placeHandles();			this.drawBorder();			showDateRange(null);		}		function handleMouseUp(e:MouseEvent) {			switch (this.mouseOffTarget) {				case this.wholeSlider.middleSlider :					this.wholeSlider.middleSlider.stopDrag();					this.controller.stage.removeEventListener(MouseEvent.MOUSE_MOVE, sliderDragging);					break;				case this.leftHandle :					this.leftHandle.stopDrag();					this.controller.stage.removeEventListener(MouseEvent.MOUSE_MOVE, handleDragging);					this.resizeMiddleSlider();					positionGraph(true);					break;				case this.rightHandle :					this.rightHandle.stopDrag();					this.controller.stage.removeEventListener(MouseEvent.MOUSE_MOVE, handleDragging);					this.resizeMiddleSlider();					positionGraph(true);					break;				case this.wholeSlider.left :					clearInterval(buttonInterval);					break;				case this.wholeSlider.right :					clearInterval(buttonInterval);					break;			}			this.controller.stage.removeEventListener(MouseEvent.MOUSE_UP, handleMouseUp);			dispatchEvent(new Event(TimeSeriesGraph.RANGE_CHANGED));		}		function resizeMiddleSlider() {			var handleDiff = rightHandle.x-leftHandle.x;			var myTween:Tween = new Tween(this.wholeSlider.middleSlider, "x", Regular.easeIn, this.wholeSlider.middleSlider.x, this.leftHandle.x, 2);			var myTween2:Tween = new Tween(this.wholeSlider.middleSlider.bg, "width", Regular.easeIn, this.wholeSlider.middleSlider.bg.width, handleDiff, 2);			myTween2.addEventListener(TweenEvent.MOTION_FINISH, onTweenFinished);		}		function onTweenFinished(e:TweenEvent) {			drawBorder();			moveHandleMask();		}		public function drawGraphs(valueArray:Array, dateArray:Array) {			if (!this.hasGraph) {				setGraphSize(this.totalWidth, this.totalHeight);				this.firstGraphing();			}			this.dateArray = dateArray;			this.valueArray = valueArray;			this.positionArray = new Array();			this.realPositionArray = new Array();			var count;			var tempX = 0;			var tempY;			//totalTimeWidth = dateArray[dateArray.length-1].valueOf() - dateArray[0].valueOf();			mainGraph.graphics.clear();			smallGraph.graphics.clear();			blueGraph.graphics.clear();			mainGraph.graphics.beginFill(0xEDF7FF, 1);			mainGraph.graphics.lineStyle(1, 0x3B8AE5, 1.0, false, "none");			mainGraph.graphics.moveTo(0,0);			smallGraph.graphics.beginFill(0xF8F8F8, 1);			smallGraph.graphics.lineStyle(1, 0xDDDDDD, 1, false, "none");			smallGraph.graphics.moveTo(0,0);			blueGraph.graphics.beginFill(0xEDF7FF, 1);			blueGraph.graphics.lineStyle(1, 0x3B8AE5, 1, false, "none");			blueGraph.graphics.moveTo(0,0);			for (var a=0; a<valueArray.length; a++) {// for each value in the value array				tempX = ((dateArray[a].valueOf() - dateArray[0].valueOf()))*magicMultiplier;///totalTimeWidth) * 10000;				this.positionArray.push(Math.round(tempX));				this.realPositionArray.push(tempX);				tempY = -(valueArray[a]);				if (keyArray.length > 0) {					for (var z=0; z<keyArray.length; z++) {//for each key value set by the user						if (tempY == -keyArray[z][0]) {							tempY = keyArray[z][1];						}					}				}				mainGraph.graphics.lineTo(tempX, tempY);				//generalize the small graph				var yTemp;				tempY = 0;				count = 0;				for (var b = 0; b < Math.round(valueArray.length/100); b++) {					if ((a-b)>0) {						yTemp = valueArray[a-b];						if (keyArray.length > 0) {							for (z=0; z<keyArray.length; z++) {								if (yTemp == keyArray[z][0]) {									yTemp = keyArray[z][1];								}							}						}						tempY += yTemp;						count++;					}					if ((a+b)<(valueArray.length-1)) {						yTemp = valueArray[a+b];						if (keyArray.length > 0) {							for (z=0; z<keyArray.length; z++) {								if (yTemp == keyArray[z][0]) {									yTemp = keyArray[z][1];								}							}						}						tempY += yTemp;						count++;					}				}				tempY = -(tempY/count);				smallGraph.graphics.lineTo(tempX, tempY);				blueGraph.graphics.lineTo(tempX, tempY);			}			mainGraph.graphics.lineTo(tempX, 0);			mainGraph.graphics.lineStyle(0, 0xCCCCCC, 0);			mainGraph.graphics.lineTo(0,0);			smallGraph.graphics.lineTo(tempX,0);			smallGraph.graphics.lineTo(0,0);			blueGraph.graphics.lineTo(tempX, 0);			blueGraph.graphics.lineStyle(0, 0xCCCCCC, 0);			blueGraph.graphics.lineTo(0,0);			smallGraph.x = this.wholeSlider.left.width;			blueGraph.x = this.wholeSlider.left.width;			graphHolder.mask = largeMask;			blueGraph.mask = handleMask;			positionGraph(false);			this.setGraphSize(this.totalWidth, this.totalHeight);		}		public function applySecondGraph(valueArray:Array, dateArray:Array) {			graphHolder.addChild(barGraph);			this.secondDateArray = dateArray;			this.secondValueArray = valueArray;			this.secondGraph = true;			barGraph.graphics.clear();			barGraph.graphics.lineStyle(1.5, 0x0099cc, 1, false, "none");			barGraph.graphics.moveTo(0,0);			var tempX = 0;			var tempY = 0;			secondPositionArray = new Array();			secondRealPositionArray = new Array();			for (var a=0; a<this.secondValueArray.length; a++) {				tempX = ((this.secondDateArray[a].valueOf() - this.secondDateArray[0].valueOf()))*magicMultiplier;///totalTimeWidth) * 10000;				this.secondPositionArray.push(Math.round(tempX));				this.secondRealPositionArray.push(tempX);				tempY = -(this.secondValueArray[a] * 20);				barGraph.graphics.moveTo(tempX, 0);				barGraph.graphics.lineTo(tempX, tempY);			}			barGraph.graphics.moveTo(tempX, 0);			barGraph.graphics.lineTo(0,0);			this.setGraphSize(this.totalWidth, this.totalHeight);		}		public function removeSecondGraph() {			graphHolder.removeChild(barGraph);			this.secondGraph = false;			this.setGraphSize(this.totalWidth, this.totalHeight);		}		function positionGraph(toTween) {			var tempwidth = (smallWidth/(this.rightHandle.x - this.leftHandle.x)) * mainWidth;			var tempx = -((1-((this.rightHandle.x - this.leftHandle.x)/smallWidth))*((this.leftHandle.x-this.wholeSlider.left.width)/(smallWidth-(this.rightHandle.x-this.leftHandle.x)))*((smallWidth/(this.rightHandle.x - this.leftHandle.x)) * mainWidth));			if (isNaN(tempx)) {				tempx = 0;			}			if (!toTween) {				graphHolder.width = tempwidth;				graphHolder.x = tempx;			} else if (toTween) {				new Tween(this.graphHolder, "width", Regular.easeIn, this.graphHolder.width,  tempwidth, 2);				new Tween(this.graphHolder, "x", Regular.easeIn, this.graphHolder.x, tempx, 2);			}			trace("tempwidth: " + tempwidth);			trace("tempx: " + tempx);		}		function showSpecifics(e:MouseEvent) {			this.header.dateText.textColor = 0x0066cc;			this.background.addEventListener(MouseEvent.MOUSE_MOVE, moveDot);		}		function moveDot(e:MouseEvent) {			var xOnGraph = this.mainGraph.mouseX;			var tempIndex = this.positionArray.indexOf(Math.round(xOnGraph));			var dotY;			var dotValue;			if (tempIndex == -1) {// if the mouse is not very close to a date that has a value, find the closest valuse/vertex				var z = 1;				while (tempIndex == -1 && z<100) {					tempIndex = this.positionArray.indexOf(Math.round(xOnGraph + (z * .5)));					if (tempIndex != -1) {						break;					}					tempIndex = this.positionArray.indexOf(Math.round(xOnGraph - (z * .5)));					z++;				}			}			if (z!=100) {				if (!this.dot.visible) {					this.dot.visible = true;				}				dotY = dotValue = valueArray[tempIndex];				if (keyArray.length > 0) {					for (var aaa=0; aaa<keyArray.length; aaa++) {						if (dotY == keyArray[aaa][0]) {							dotY = keyArray[aaa][1];							dotValue = keyArray[aaa][2];						}					}				}				this.dot.x = (this.realPositionArray[tempIndex] * graphHolder.scaleX) * mainGraph.scaleX + graphHolder.x + (mainGraph.x * graphHolder.scaleX);				this.dot.y = this.graphHolder.y + mainHeight - (dotY * mainGraph.scaleY);				this.header.dateText.text = dateArray[tempIndex].toDateString() + " " + this.mainLabel + ": " + dotValue + " " + this.mainPost;			} else {				dot.visible = false;				this.header.dateText.text = "No " + this.mainLabel + " data";			}			if (this.secondGraph == true) {				xOnGraph = this.barGraph.mouseX;				if (!this.bar.visible) {					this.bar.visible = true;				}				tempIndex = this.secondPositionArray.indexOf(Math.round(xOnGraph));				if (tempIndex == -1) {// if the mouse is not very close to a date that has a value, find the closest valuse/vertex					z = 1;					while (tempIndex == -1 && z<100) {						tempIndex = this.secondPositionArray.indexOf(Math.round(xOnGraph + (z * .5)));						if (tempIndex != -1) {							break;						}						tempIndex = this.secondPositionArray.indexOf(Math.round(xOnGraph - (z * .5)));						z++;					}				}				if (z!=100) {					this.bar.x = (this.secondRealPositionArray[tempIndex] * graphHolder.scaleX) * barGraph.scaleX + graphHolder.x + (barGraph.x * graphHolder.scaleX);					this.bar.y = this.graphHolder.y + totalGraphHeight;					this.bar.height = this.secondValueArray[tempIndex] * 20 * barGraph.scaleY;					if (this.header.dateText.text.substr(0,2) == "No") {						this.header.dateText.text += ", " + secondDateArray[tempIndex].toDateString() + " " + this.secondLabel + ": " + secondValueArray[tempIndex] + " " + this.secondPost;					} else {						this.header.dateText.text += ", " + this.secondLabel + ": " + secondValueArray[tempIndex] + " " + this.secondPost;					}				} else {					bar.visible = false;					this.header.dateText.text += ", No " + this.secondLabel + " data";				}			}			if (this.dot.x < 0 || this.dot.x > mainWidth) {				this.dot.visible = false;				//this.bar.visible = false;			}			if (this.bar.x < 0 || this.bar.x > mainWidth) {				this.bar.visible = false;			}		}		function showDateRange(e:MouseEvent) {			if (dot.visible || bar.visible) {				dot.visible = false;				bar.visible = false;			}			this.header.dateText.textColor = 0x333333;			var dateFiguring = ((this.leftHandle.x - this.wholeSlider.left.width) / (this.wholeSlider.width - this.wholeSlider.left.width * 2)) * (dateArray[dateArray.length-1].valueOf() - dateArray[0].valueOf()) + dateArray[0].valueOf();			leftDate = new Date(dateFiguring);			dateFiguring += ((rightHandle.x - leftHandle.x) / (this.wholeSlider.width - this.wholeSlider.left.width * 2)) * (dateArray[dateArray.length-1].valueOf() - dateArray[0].valueOf());			rightDate = new Date(dateFiguring);			this.header.dateText.text = leftDate.toDateString() + " " + leftDate.toLocaleTimeString() + " - " + rightDate.toDateString() + " " + rightDate.toLocaleTimeString();		}		public function changeLabels(label1=null, label2=null, post1=null, post2=null) {			if (label1!=null) {				this.mainLabel = label1;			}			if (label2!=null) {				this.secondLabel = label2;			}			if (post1!=null) {				this.mainPost = post1;			}			if (post2!=null) {				this.secondPost = post2;			}		}		public function keyValues(keyArray) {			if (keyArray.length == 3) {				this.keyArray.push(keyArray);			}			//the first position in the passed array should be the value to catch (ie. -33)			//the second position in the passed array should be the value to translate this to when creating the line graphs (ie. 0)			//the third position in the passed array should be the id to translate this to on display (ie. "ice")		}		public function mainAverage() {			if (this.hasGraph) {				var tempAvg = 0;				var obs = 0;				var minI=0;				while (this.leftDate.valueOf()>this.dateArray[minI].valueOf()) {					minI++;				}				while (this.dateArray[minI].valueOf() < this.rightDate.valueOf()) {					tempAvg += this.valueArray[minI];					minI++;					obs++;				}				tempAvg = tempAvg/obs;				return tempAvg;			}		}		public function mainMax() {			if (this.hasGraph) {				var tempMax=0;				var minI=0;				while (this.leftDate.valueOf()>this.dateArray[minI].valueOf()) {					minI++;				}				while (this.dateArray[minI].valueOf() < this.rightDate.valueOf()) {					if (this.valueArray[minI] > tempMax) {						tempMax = this.valueArray[minI];					}					minI++;				}				return tempMax;			}		}		public function mainMin() {			if (this.hasGraph) {				var tempMin=999999999999999999;				var minI=0;				while (this.leftDate.valueOf()>this.dateArray[minI].valueOf()) {					minI++;				}				while (this.dateArray[minI].valueOf() < this.rightDate.valueOf()) {					if (this.valueArray[minI] < tempMin) {						tempMin = this.valueArray[minI];					}					minI++;				}				return tempMin;			}		}	}}